use std::ops::IndexMut;

///! Optimizations for the MIR
use calamars_core::Identifier;
use hashbrown::HashMap;

use crate::{
    BBlock, Function, VInstruct, VInstructionKind, ValueId, errors::MirErrors, lower::MirRes,
};

/// An optimization pass on some function
pub trait OptFunction {
    type PassContext: Into<OptLevel>;
    type PassOutput;

    /// Name
    fn name(&self) -> &'static str;

    /// Description
    fn desc(&self) -> &'static str;

    /// Run optimization on the inputted function
    fn optimize(&mut self, f: &mut Function, ctx: Self::PassContext) -> MirRes<Self::PassOutput>;
}

pub enum OptLevel {
    None,
    All,
}

impl Into<OptLevel> for usize {
    fn into(self) -> OptLevel {
        match self {
            0 => OptLevel::None,
            _ => OptLevel::All,
        }
    }
}

pub struct TailCallOptimization {
    /// how many times was a valueid used
    usages: HashMap<ValueId, usize>,
}

impl TailCallOptimization {
    pub fn new() -> Self {
        Self {
            usages: HashMap::new(),
        }
    }

    fn insert_usage(&mut self, vid: &ValueId) {
        if let Some(usagec) = self.usages.get_mut(vid) {
            *usagec += 1;
        } else {
            self.usages.insert(*vid, 1);
        }
    }

    fn fill_usage_with_instructions(&mut self, f: &Function) {
        for vinst in &f.instructions {
            match &vinst.kind {
                VInstructionKind::Binary { lhs, rhs, .. }
                | VInstructionKind::BitwiseBinary { lhs, rhs, .. } => {
                    self.insert_usage(lhs);
                    self.insert_usage(rhs);
                }
                VInstructionKind::Unary { on, .. } => self.insert_usage(on),
                VInstructionKind::Call { args, .. } => {
                    args.iter().for_each(|vid| self.insert_usage(vid))
                }
                _ => {}
            };
        }
    }

    fn fill_usage_with_terminators(&mut self, blocks: &[BBlock]) {
        for block in blocks {
            if let Some(term) = &block.finally {
                match term {
                    crate::Terminator::Return(Some(vid))
                    | crate::Terminator::BrIf { condition: vid, .. } => self.insert_usage(vid),
                    crate::Terminator::Call { args, .. } => {
                        args.iter().for_each(|vid| self.insert_usage(vid))
                    }
                    _ => {}
                }
            }
        }
    }

    fn fill_usages(&mut self, f: &Function) {
        self.fill_usage_with_instructions(f);
        self.fill_usage_with_terminators(&f.blocks);
    }

    /// Return blocks by id that need to be tail call optimized
    fn blocks_to_update(&mut self, f: &Function) -> Vec<usize> {
        let mut block_ids = vec![];
        for (id, block) in f.blocks.iter().enumerate() {
            if let Some(crate::Terminator::Return(Some(v))) = &block.finally {
                // check if the value id came from a function call
                let inst = f.instructions.get(v.inner_id()).unwrap();
                if matches!(&inst.kind, VInstructionKind::Call { .. })
					// It was only used in the return statement and exactly once
					&& self.usages[v] == 1
				    // It was the last thing done in the block (this is important due to the possibility of side effects)
					&& block.instructs.last().is_some_and(|x| x == v)
                {
                    block_ids.push(id)
                }
            }
        }
        block_ids
    }

    // This is a little iffy - If the terminator fails, we have already popped the instruction so we will have
    // invalid MIR. Oh well, this is a pre alpha mainly for testing, so we will allow it for now, and add a TODO.
    fn update_block(&mut self, f: &mut Function, blockid: usize) -> MirRes<()> {
        let block = &mut f.blocks[blockid];
        let last = block
            .instructs
            .pop()
            .ok_or(MirErrors::InstructionListWasEmpty)?;
        let terminator = f
            .instructions
            .get(last.inner_id())
            .ok_or(MirErrors::InstNotFound)?
            .kind
            .call_to_terminator()?;
        block.finally = Some(terminator);
        Ok(())
    }
}

impl OptFunction for TailCallOptimization {
    type PassContext = usize;
    type PassOutput = ();

    fn name(&self) -> &'static str {
        "Tail call optimization"
    }

    fn desc(&self) -> &'static str {
        "If the terminator instruction points to the data generated by a function call, we can tail call optimize."
    }

    fn optimize(&mut self, f: &mut Function, _ctx: Self::PassContext) -> MirRes<Self::PassOutput> {
        self.fill_usages(f);
        let to_update = self.blocks_to_update(&f);
        for block_id in to_update {
            self.update_block(f, block_id)?;
        }
        Ok(())
    }
}
